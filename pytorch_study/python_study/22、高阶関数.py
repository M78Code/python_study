## 函数式编程
#   - 在Python中，函数是一等对象
#   一等对象一般都会具有如下特点:
#    1，对象是在运行时创建的
#    2，能赋值给变量或作为数据结构中的元素
#    3，能作为参数传递
#    4，能作为返回值返回

#  高阶函数
#   -高阶函数至少要符合以下两个特点中的一个
#   1，接收一个或多个函数作为参数
#   2，将函数作为返回值返回 

#  创建一个列表
from turtle import RawTurtle


l = [1,2,3,4,5,6,7,8,9,10]

# 定义一个函数
#   可以将指定列表中的所有的偶数，保存到一个新的列表中返回

def fn(lst):
    '''
        fn()函数可以将指定列表中的所有偶数取出来，并保存到一个新列表中返回
        参数:
            lst : 要进行筛选的列表
    '''
    # 创建一个新列表
    new_list = []
    # 对列表进行筛选
    for n in lst:
        if n % 2 == 0:
            new_list.append(n)
    
    # 返回新列表
    return new_list

print(fn(l))

def fn4(i):
    return i % 3 == 0

lambda i : i % 3 == 0

# filter()
# filter()可以从序列中过滤出符合条件的元素，保存到一个新的序列中
# 参数:
#   1. 函数，根据该函数来过滤序列（可迭代的结构）
#   2. 需要过滤的序列（可迭代的结构）
#  返回值:
#    过滤后的新序列（可迭代的结构）

# fn4是作为参数传递进filter()函数中
#   而fn4实际上只有一个作用，就是作为filter()的参数
#       filter()调用完毕以后，fn4就已经没用

#   匿名函数 lambda 函数表达式
#       lambda函数表达式专门用来创建一些简单的函数，他是函数创建的又一种方式
#       语法: lambda 参数列表 : 返回值
#       匿名函数一般都是作为参数使用，其他地方一般不会使用

def fn5(a,b):
    return a+b

lambda a,b : a+b

# 调用方法 (lambda a, b : a+b)(10,20)
print((lambda a, b : a+b)(10,20))

#  map()
#  map()函数可以对可迭代对象中的所有元素做指定的操作，
#   然后将其添加到一个新的对象中返回
l = [1,2,3,4,5,6,7,8,9,10]
r = map(lambda i : i+1, l)

# sort()
# 该方法用来对列表中的元素进行排序
# sort()方法默认是直接比较列表中的元素的大小
# 在sort()可以接收一个关键字参数key，
# 每次都会以列表中的一个元素作为参数来调用函数，并且使用函数的返回值来比较元素的大小

ll = ['bb','aaaa','c','dddddddd','fff']
ll.sort(key = len)
print(ll)

l2 = [2,5,'1',3,'6','4']
l2.sort(key=str)# key = str表示把l2中每个值转成字符串再进行比较
l2.sort(key=int)# key = int表示把l2中每个值转成int再进行比较
print(l2)

# sorted()
# 这个函数和sort()的用法基本一致，但是sorted()可以任意的序列进行排序
#   并且使用sorted()排序不会影响原来的对象，而是返回一个新对象

print("排序前:",l2)
print(sorted(l2,key=int))
print('排序后:', l2)

# 将函数作为返回值返回，也是一种高阶函数

def fn3():
    # 函数内部再定义一个函数
    def inner():
        print("我是fn2")
    # 将内部函数inner作为返回值返回
    return inner

# r是一个函数，是调用fn()后返回的函数
# 这个函数是在fn()内部定义，并不是全局函数
# 所以这个函数总是能访问fn()函数内的变量


# 将函数作为返回值返回，也是一种高阶函数
# 这种高阶函数我们也称为闭包，通过闭包可以创建一些只有当前函数能访问的变量
#   可以将一些私有的数据量藏到闭包中

# 求多个数的平均值
nums = [50,30,20,10,77]

# sum()用来求一个列表中所有元素的和
print(sum(nums)/len(nums))

# 创建一个列表，用来保存数值
listArray = []

# 创建一个函数，用来计算平均值
def averager(n):
    # 将n添加到列表中
    listArray.append(n)
    # 求平均值
    return sum(listArray)/len(listArray)

# 形成闭包的要件
#   1，函数嵌套
#   2，将内部函数作为返回值返回
#   3，内部函数必须要使用到外部函数的变量
def make_averager():
    # 创建一个列表，用来保存数值
    nums = []

    # 创建一个函数，用来计算平均值
    def averager(n):
        # 将n添加到列表中
        nums.append(n)
        # 求平均值
        return sum(nums)/len(nums)
    
    return averager

test_averager = make_averager()
print(test_averager(10))

# 创建几个函数
def add(a,b):
    '''
        求任意两个数的和
    '''
    return a+b

def mul(a,b):
    '''
        求任意两个数的积
    '''
    return a*b

# 希望函数可以在计算前，打印开始计算，计算结束后打印计算完毕
#   我们可以直接通过个性函数中的代码来完成需求，但是会产生以下一些问题
#   1，如果要个性的函数过多，个性起来会比较麻烦
#   2，并且不方便后期的维护
#   3，并且这样做会违反开闭原则（OCP）
#       程序的设计，要求开发对程序的扩展，要关闭对程序的修改

# 只要根据现有的函数，来创建一个新的函数
def fn2(a,b):
    print('函数开始执行～～～')
    r = add(a,b)
    print('函数结束～～～')
    return r

# r = new_add(111,222)
# print(r)

# 上边的方式，已经可以在不修改源代码的情况下对函数，进行扩展了
#   但是，这种方式要求我们每扩展一个函数就要手动创建一个新的函数，
#       创建一个函数，让这个函数可以自动的帮助生产函数

def begin_end():
    '''
        用来对其他函数进行扩展，使用其他函数可以在执行前打印
    '''


